{"version":3,"file":"index.cjs","sources":["../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/symbol.js","../../../../node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/util.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/interface.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/redis.js","../../../../node_modules/.pnpm/obliterator@2.0.5/node_modules/obliterator/iterator.js","../../../../node_modules/.pnpm/obliterator@2.0.5/node_modules/obliterator/support.js","../../../../node_modules/.pnpm/obliterator@2.0.5/node_modules/obliterator/foreach.js","../../../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/typed-arrays.js","../../../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/utils/iterables.js","../../../../node_modules/.pnpm/mnemonist@0.39.8/node_modules/mnemonist/lru-cache.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/memory.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/storage/index.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/src/cache.js","../../../../node_modules/.pnpm/async-cache-dedupe@2.2.0/node_modules/async-cache-dedupe/index.js","../../../../node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/task/index.js","../../../../node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/clean-stores/index.js","../../../../node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/atom/index.js","../../../../node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/lifecycle/index.js","../../../../node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/map/index.js","../../src/env.ts","../../src/live-mode/index.ts","../../src/index.ts"],"sourcesContent":["'use strict'\n\nconst kValues = Symbol('values')\nconst kStorage = Symbol('kStorage')\nconst kStorages = Symbol('kStorages')\nconst kTransfromer = Symbol('kTransformer')\nconst kTTL = Symbol('kTTL')\nconst kOnDedupe = Symbol('kOnDedupe')\nconst kOnError = Symbol('kOnError')\nconst kOnHit = Symbol('kOnHit')\nconst kOnMiss = Symbol('kOnMiss')\nconst kStale = Symbol('kStale')\n\nmodule.exports = { kValues, kStorage, kStorages, kTransfromer, kTTL, kOnDedupe, kOnError, kOnHit, kOnMiss, kStale }\n","'use strict'\n\nconst { hasOwnProperty } = Object.prototype\n\nconst stringify = configure()\n\n// @ts-expect-error\nstringify.configure = configure\n// @ts-expect-error\nstringify.stringify = stringify\n\n// @ts-expect-error\nstringify.default = stringify\n\n// @ts-expect-error used for named export\nexports.stringify = stringify\n// @ts-expect-error used for named export\nexports.configure = configure\n\nmodule.exports = stringify\n\n// eslint-disable-next-line no-control-regex\nconst strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]/\n\n// Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\nfunction strEscape (str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 8.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return `\"${str}\"`\n  }\n  return JSON.stringify(str)\n}\n\nfunction sort (array, comparator) {\n  // Insertion sort is very efficient for small input sizes, but it has a bad\n  // worst case complexity. Thus, use native array sort for bigger values.\n  if (array.length > 2e2 || comparator) {\n    return array.sort(comparator)\n  }\n  for (let i = 1; i < array.length; i++) {\n    const currentValue = array[i]\n    let position = i\n    while (position !== 0 && array[position - 1] > currentValue) {\n      array[position] = array[position - 1]\n      position--\n    }\n    array[position] = currentValue\n  }\n  return array\n}\n\nconst typedArrayPrototypeGetSymbolToStringTag =\n  Object.getOwnPropertyDescriptor(\n    Object.getPrototypeOf(\n      Object.getPrototypeOf(\n        new Int8Array()\n      )\n    ),\n    Symbol.toStringTag\n  ).get\n\nfunction isTypedArrayWithEntries (value) {\n  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0\n}\n\nfunction stringifyTypedArray (array, separator, maximumBreadth) {\n  if (array.length < maximumBreadth) {\n    maximumBreadth = array.length\n  }\n  const whitespace = separator === ',' ? '' : ' '\n  let res = `\"0\":${whitespace}${array[0]}`\n  for (let i = 1; i < maximumBreadth; i++) {\n    res += `${separator}\"${i}\":${whitespace}${array[i]}`\n  }\n  return res\n}\n\nfunction getCircularValueOption (options) {\n  if (hasOwnProperty.call(options, 'circularValue')) {\n    const circularValue = options.circularValue\n    if (typeof circularValue === 'string') {\n      return `\"${circularValue}\"`\n    }\n    if (circularValue == null) {\n      return circularValue\n    }\n    if (circularValue === Error || circularValue === TypeError) {\n      return {\n        toString () {\n          throw new TypeError('Converting circular structure to JSON')\n        }\n      }\n    }\n    throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined')\n  }\n  return '\"[Circular]\"'\n}\n\nfunction getDeterministicOption (options) {\n  let value\n  if (hasOwnProperty.call(options, 'deterministic')) {\n    value = options.deterministic\n    if (typeof value !== 'boolean' && typeof value !== 'function') {\n      throw new TypeError('The \"deterministic\" argument must be of type boolean or comparator function')\n    }\n  }\n  return value === undefined ? true : value\n}\n\nfunction getBooleanOption (options, key) {\n  let value\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key]\n    if (typeof value !== 'boolean') {\n      throw new TypeError(`The \"${key}\" argument must be of type boolean`)\n    }\n  }\n  return value === undefined ? true : value\n}\n\nfunction getPositiveIntegerOption (options, key) {\n  let value\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key]\n    if (typeof value !== 'number') {\n      throw new TypeError(`The \"${key}\" argument must be of type number`)\n    }\n    if (!Number.isInteger(value)) {\n      throw new TypeError(`The \"${key}\" argument must be an integer`)\n    }\n    if (value < 1) {\n      throw new RangeError(`The \"${key}\" argument must be >= 1`)\n    }\n  }\n  return value === undefined ? Infinity : value\n}\n\nfunction getItemCount (number) {\n  if (number === 1) {\n    return '1 item'\n  }\n  return `${number} items`\n}\n\nfunction getUniqueReplacerSet (replacerArray) {\n  const replacerSet = new Set()\n  for (const value of replacerArray) {\n    if (typeof value === 'string' || typeof value === 'number') {\n      replacerSet.add(String(value))\n    }\n  }\n  return replacerSet\n}\n\nfunction getStrictOption (options) {\n  if (hasOwnProperty.call(options, 'strict')) {\n    const value = options.strict\n    if (typeof value !== 'boolean') {\n      throw new TypeError('The \"strict\" argument must be of type boolean')\n    }\n    if (value) {\n      return (value) => {\n        let message = `Object can not safely be stringified. Received type ${typeof value}`\n        if (typeof value !== 'function') message += ` (${value.toString()})`\n        throw new Error(message)\n      }\n    }\n  }\n}\n\nfunction configure (options) {\n  options = { ...options }\n  const fail = getStrictOption(options)\n  if (fail) {\n    if (options.bigint === undefined) {\n      options.bigint = false\n    }\n    if (!('circularValue' in options)) {\n      options.circularValue = Error\n    }\n  }\n  const circularValue = getCircularValueOption(options)\n  const bigint = getBooleanOption(options, 'bigint')\n  const deterministic = getDeterministicOption(options)\n  const comparator = typeof deterministic === 'function' ? deterministic : undefined\n  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth')\n  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth')\n\n  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {\n    let value = parent[key]\n\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n    value = replacer.call(parent, key, value)\n\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n        let join = ','\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let whitespace = ''\n        let separator = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (deterministic && !isTypedArrayWithEntries(value)) {\n          keys = sort(keys, comparator)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":${whitespace}\"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key)\n    }\n\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        const originalIndentation = indentation\n        let res = ''\n        let join = ','\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          if (spacer !== '') {\n            indentation += spacer\n            res += `\\n${indentation}`\n            join = `,\\n${indentation}`\n          }\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          if (spacer !== '') {\n            res += `\\n${originalIndentation}`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n        stack.push(value)\n        let whitespace = ''\n        if (spacer !== '') {\n          indentation += spacer\n          join = `,\\n${indentation}`\n          whitespace = ' '\n        }\n        let separator = ''\n        for (const key of replacer) {\n          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`\n            separator = join\n          }\n        }\n        if (spacer !== '' && separator.length > 1) {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifyIndent (key, value, stack, spacer, indentation) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again.\n          if (typeof value !== 'object') {\n            return stringifyIndent(key, value, stack, spacer, indentation)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n        const originalIndentation = indentation\n\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          indentation += spacer\n          let res = `\\n${indentation}`\n          const join = `,\\n${indentation}`\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)\n            res += tmp !== undefined ? tmp : 'null'\n            res += join\n          }\n          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `${join}\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          res += `\\n${originalIndentation}`\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        indentation += spacer\n        const join = `,\\n${indentation}`\n        let res = ''\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, join, maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = join\n        }\n        if (deterministic) {\n          keys = sort(keys, comparator)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}: ${tmp}`\n            separator = join\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\": \"${getItemCount(removedKeys)} not stringified\"`\n          separator = join\n        }\n        if (separator !== '') {\n          res = `\\n${indentation}${res}\\n${originalIndentation}`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringifySimple (key, value, stack) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value)\n      case 'object': {\n        if (value === null) {\n          return 'null'\n        }\n        if (typeof value.toJSON === 'function') {\n          value = value.toJSON(key)\n          // Prevent calling `toJSON` again\n          if (typeof value !== 'object') {\n            return stringifySimple(key, value, stack)\n          }\n          if (value === null) {\n            return 'null'\n          }\n        }\n        if (stack.indexOf(value) !== -1) {\n          return circularValue\n        }\n\n        let res = ''\n\n        const hasLength = value.length !== undefined\n        if (hasLength && Array.isArray(value)) {\n          if (value.length === 0) {\n            return '[]'\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Array]\"'\n          }\n          stack.push(value)\n          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)\n          let i = 0\n          for (; i < maximumValuesToStringify - 1; i++) {\n            const tmp = stringifySimple(String(i), value[i], stack)\n            res += tmp !== undefined ? tmp : 'null'\n            res += ','\n          }\n          const tmp = stringifySimple(String(i), value[i], stack)\n          res += tmp !== undefined ? tmp : 'null'\n          if (value.length - 1 > maximumBreadth) {\n            const removedKeys = value.length - maximumBreadth - 1\n            res += `,\"... ${getItemCount(removedKeys)} not stringified\"`\n          }\n          stack.pop()\n          return `[${res}]`\n        }\n\n        let keys = Object.keys(value)\n        const keyLength = keys.length\n        if (keyLength === 0) {\n          return '{}'\n        }\n        if (maximumDepth < stack.length + 1) {\n          return '\"[Object]\"'\n        }\n        let separator = ''\n        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)\n        if (hasLength && isTypedArrayWithEntries(value)) {\n          res += stringifyTypedArray(value, ',', maximumBreadth)\n          keys = keys.slice(value.length)\n          maximumPropertiesToStringify -= value.length\n          separator = ','\n        }\n        if (deterministic) {\n          keys = sort(keys, comparator)\n        }\n        stack.push(value)\n        for (let i = 0; i < maximumPropertiesToStringify; i++) {\n          const key = keys[i]\n          const tmp = stringifySimple(key, value[key], stack)\n          if (tmp !== undefined) {\n            res += `${separator}${strEscape(key)}:${tmp}`\n            separator = ','\n          }\n        }\n        if (keyLength > maximumBreadth) {\n          const removedKeys = keyLength - maximumBreadth\n          res += `${separator}\"...\":\"${getItemCount(removedKeys)} not stringified\"`\n        }\n        stack.pop()\n        return `{${res}}`\n      }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'\n      case 'boolean':\n        return value === true ? 'true' : 'false'\n      case 'undefined':\n        return undefined\n      case 'bigint':\n        if (bigint) {\n          return String(value)\n        }\n        // fallthrough\n      default:\n        return fail ? fail(value) : undefined\n    }\n  }\n\n  function stringify (value, replacer, space) {\n    if (arguments.length > 1) {\n      let spacer = ''\n      if (typeof space === 'number') {\n        spacer = ' '.repeat(Math.min(space, 10))\n      } else if (typeof space === 'string') {\n        spacer = space.slice(0, 10)\n      }\n      if (replacer != null) {\n        if (typeof replacer === 'function') {\n          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')\n        }\n        if (Array.isArray(replacer)) {\n          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')\n        }\n      }\n      if (spacer.length !== 0) {\n        return stringifyIndent('', value, [], spacer, '')\n      }\n    }\n    return stringifySimple('', value, [])\n  }\n\n  return stringify\n}\n","'use strict'\n\n/**\n * arrays must be sorted and unique\n * @param {*} arrayA\n * @param {*} arrayB\n * @returns {number[]} matching indexes of arrayB\n */\nfunction findMatchingIndexes (arrayA, arrayB) {\n  const found = []\n\n  let lastIndexB = 0\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    for (let indexB = lastIndexB; indexB < arrayB.length; indexB++) {\n      if (arrayA[indexA] === arrayB[indexB]) {\n        found.push(indexB)\n        lastIndexB = indexB + 1\n      }\n    }\n  }\n  return found\n}\n\n/**\n * arrays must be sorted and unique\n * @param {*} arrayA\n * @param {*} arrayB\n * @returns {number[]} values of arrayB not in arrayA\n */\nfunction findNotMatching (arrayA, arrayB) {\n  const found = []\n\n  let lastIndexB = 0\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    for (let indexB = lastIndexB; indexB < arrayB.length; indexB++) {\n      if (arrayA[indexA] !== arrayB[indexB]) {\n        found.push(arrayB[indexB])\n        lastIndexB = indexB + 1\n      }\n    }\n  }\n  return found\n}\n\n/**\n * @param {*} array\n * @param {*} value\n * @return {number} index of value in array, -1 if not found\n */\nfunction bsearchIndex (array, value) {\n  let start = 0\n  let end = array.length - 1\n\n  while (start <= end) {\n    const index = ((start + end) / 2) | 0\n\n    if (array[index] === value) {\n      return index\n    }\n\n    if (array[index] < value) {\n      start = index + 1\n    } else {\n      end = index - 1\n    }\n  }\n\n  return -1\n}\n\nfunction randomNumber (max) {\n  return (max * Math.random()) | 0\n}\n\nfunction randomInRange (min, max) {\n  min = Math.floor(min)\n  max = Math.floor(max)\n  return min + randomNumber(1 + max - min)\n}\n\nfunction randomSubset (array, size) {\n  if (array.length < 1 || size < 1) return []\n\n  const limit = Math.min(array.length, size)\n  const n = randomInRange(1, limit)\n  const indexes = new Set()\n  for (let i = 0; i < n; i++) {\n    indexes.add(randomNumber(array.length))\n  }\n  const result = []\n  for (const i of indexes) {\n    result.push(array[i])\n  }\n\n  return result\n}\n\n/**\n * @param {!string} value substring to search in content, supporting wildcard\n * @param {!string} content string to search in\n * @return {boolean} true if value is in content\n * @example wildcardMatch(\"1*5\", \"12345\") > true\n * @example wildcardMatch(\"1*6\", \"12345\") > false\n */\nfunction wildcardMatch (value, content) {\n  if (value === '*') return true\n  if (value.length === content.length && value === content) return true\n\n  let i = 0; let j = 0\n  while (i < value.length && j < content.length) {\n    if (value[i] === content[j]) {\n      i++\n      j++\n      continue\n    }\n    if (value[i] === '*') {\n      if (value[i + 1] === content[j]) {\n        i++\n        continue\n      }\n      j++\n      continue\n    }\n    return false\n  }\n\n  return i >= value.length - 1\n}\n\n// `abstract-logging` dependency has been removed because there is a bug on Rollup\n// https://github.com/jsumners/abstract-logging/issues/6\nfunction abstractLogging () {\n  const noop = () => {}\n  return {\n    fatal: noop,\n    error: noop,\n    warn: noop,\n    info: noop,\n    debug: noop,\n    trace: noop\n  }\n}\n\nconst isServerSide = typeof window === 'undefined'\n\nmodule.exports = {\n  findNotMatching,\n  findMatchingIndexes,\n  bsearchIndex,\n  wildcardMatch,\n  randomSubset,\n  abstractLogging,\n  isServerSide\n}\n","'use strict'\n\nclass StorageInterface {\n  constructor (options) {\n    this.options = options\n  }\n\n  /**\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found\n   */\n  async get (key) { throw new Error('storage get method not implemented') }\n  /**\n   * @param {string} key\n   * @param {*} value\n   * @param {number} ttl - ttl in seconds; zero means key will not be stored\n   * @param {?string[]} references\n   */\n  async set (key, value, ttl, references) { throw new Error('storage set method not implemented') }\n  /**\n   * @param {string} key\n   */\n  async remove (key) { throw new Error('storage remove method not implemented') }\n  /**\n   * @param {string[]} references\n   */\n  async invalidate (references) { throw new Error('storage invalidate method not implemented') }\n  /**\n   * @param {string} name\n   */\n  async clear (name) { throw new Error('storage clear method not implemented') }\n  async refresh () { throw new Error('storage refresh method not implemented') }\n}\n\nmodule.exports = StorageInterface\n","'use strict'\n\nconst stringify = require('safe-stable-stringify')\nconst StorageInterface = require('./interface')\nconst { findNotMatching, randomSubset, abstractLogging } = require('../util')\n\nconst GC_DEFAULT_CHUNK = 64\nconst GC_DEFAULT_LAZY_CHUNK = 64\nconst REFERENCES_DEFAULT_TTL = 60\n\n/**\n * @typedef StorageRedisOptions\n * @property {!store} client\n * @property {?Logger} log\n * @property {?Object|boolean} [invalidation=false]\n * @property {?number} [invalidation.referencesTTL=60]\n */\n\nclass StorageRedis extends StorageInterface {\n  /**\n   * @param {?StorageRedisOptions} options\n   */\n  constructor (options = {}) {\n    if (!options.client || typeof options.client !== 'object') {\n      throw new Error('Redis client is required')\n    }\n\n    super(options)\n\n    if (options.invalidation && options.invalidation.referencesTTL &&\n      (typeof options.invalidation.referencesTTL !== 'number' || options.invalidation.referencesTTL < 1)) {\n      throw new Error('invalidation.referencesTTL must be a positive integer greater than 1')\n    }\n\n    this.log = options.log || abstractLogging()\n    this.store = options.client\n    this.invalidation = !!options.invalidation\n    this.referencesTTL = (options.invalidation && options.invalidation.referencesTTL) || REFERENCES_DEFAULT_TTL\n  }\n\n  getReferenceKeyLabel (reference) {\n    return `r:${reference}`\n  }\n\n  getKeyReferenceLabel (key) {\n    return `k:${key}`\n  }\n\n  /**\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found\n   */\n  async get (key) {\n    this.log.debug({ msg: 'acd/storage/redis.get', key })\n\n    try {\n      const value = await this.store.get(key)\n      if (!value) {\n        if (!this.invalidation) {\n          return undefined\n        }\n\n        // clear references because the key could be expired (or evicted)\n        // note: no await\n        this.clearReferences(key)\n        return undefined\n      }\n      return JSON.parse(value)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.get error', err, key })\n    }\n  }\n\n  /**\n   * retrieve the remaining TTL value by key\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found or expired\n   */\n  async getTTL (key) {\n    this.log.debug({ msg: 'acd/storage/memory.getTTL', key })\n\n    let pttl = await this.store.pttl(key)\n    if (pttl < 0) {\n      return 0\n    }\n\n    pttl = Math.ceil(pttl / 1000)\n\n    return pttl\n  }\n\n  /**\n   * set value by key\n   * @param {string} key\n   * @param {*} value\n   * @param {number} ttl - ttl in seconds; zero means key will not be stored\n   * @param {?string[]} references\n   */\n  async set (key, value, ttl, references) {\n    // TODO validate keys, can't contain * or other special chars\n    this.log.debug({ msg: 'acd/storage/redis.set key', key, value, ttl, references })\n\n    ttl = Number(ttl)\n    if (!ttl || ttl < 0) {\n      return\n    }\n\n    try {\n      await this.store.set(key, stringify(value), 'EX', ttl)\n\n      if (!references || references.length < 1) {\n        return\n      }\n\n      if (!this.invalidation) {\n        this.log.warn({ msg: 'acd/storage/redis.set, invalidation is disabled, references are useless', key, references })\n        return\n      }\n\n      const writes = []\n\n      // clear old references\n      const currentReferences = await this.store.smembers(this.getKeyReferenceLabel(key))\n      this.log.debug({ msg: 'acd/storage/redis.set current references', key, currentReferences })\n      if (currentReferences.length > 1) {\n        currentReferences.sort()\n        references.sort()\n        const referencesToRemove = findNotMatching(references, currentReferences)\n\n        // remove key in current references\n        for (const reference of referencesToRemove) {\n          writes.push(['srem', this.getReferenceKeyLabel(reference), key])\n        }\n        writes.push(['del', this.getKeyReferenceLabel(key)])\n      }\n\n      // TODO we can probably get referencesToAdd and referencesToRemove in a single loop\n      const referencesToAdd = currentReferences.length > 1 ? findNotMatching(currentReferences, references) : references\n      this.log.debug({ msg: 'acd/storage/redis.set references to add', key, referencesToAdd })\n\n      for (let i = 0; i < referencesToAdd.length; i++) {\n        const reference = referencesToAdd[i]\n        const referenceKeyLabel = this.getReferenceKeyLabel(reference)\n        // reference->keys\n        writes.push(['sadd', referenceKeyLabel, key])\n        // reset reference->keys ttl to max\n        writes.push(['expire', referenceKeyLabel, this.referencesTTL])\n      }\n      const keyReferenceLabel = this.getKeyReferenceLabel(key)\n      // key-references\n      writes.push(['sadd', keyReferenceLabel, references])\n      // key-references has the same ttl of key\n      writes.push(['expire', keyReferenceLabel, ttl])\n\n      this.log.debug({ msg: 'acd/storage/redis.set references writes', writes })\n\n      await this.store.pipeline(writes).exec()\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.set error', err, key, ttl, references })\n    }\n  }\n\n  /**\n   * remove an entry by key\n   * @param {string} key\n   * @returns {boolean} indicates if key was removed\n   */\n  async remove (key) {\n    this.log.debug({ msg: 'acd/storage/redis.remove', key })\n    try {\n      const removed = await this.store.del(key) > 0\n      if (removed && this.invalidation) { await this.clearReferences(key) }\n      return removed\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.remove error', err, key })\n    }\n  }\n\n  /**\n   * @param {string|string[]} references\n   * @returns {string[]} removed keys\n   */\n  async invalidate (references) {\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/redis.invalidate, exit due invalidation is disabled' })\n      return []\n    }\n\n    this.log.debug({ msg: 'acd/storage/redis.invalidate', references })\n\n    try {\n      if (Array.isArray(references)) {\n        return await this._invalidateReferences(references)\n      }\n      return await this._invalidateReference(references)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.invalidate error', err, references })\n      return []\n    }\n  }\n\n  /**\n   * @param {string[]} references\n   * @param {[bool=true]} mapReferences\n   * @returns {string[]} removed keys\n   */\n  async _invalidateReferences (references, mapReferences = true) {\n    const reads = references.map(reference => ['smembers', mapReferences ? this.getReferenceKeyLabel(reference) : reference])\n    const keys = await this.store.pipeline(reads).exec()\n\n    this.log.debug({ msg: 'acd/storage/redis._invalidateReferences keys', keys })\n\n    const writes = []\n    const removed = []\n    for (let i = 0; i < keys.length; i++) {\n      const key0 = keys[i][1]\n      if (!key0) { continue }\n      this.log.debug({ msg: 'acd/storage/redis._invalidateReferences got keys to be invalidated', keys: key0 })\n      for (let j = 0; j < key0.length; j++) {\n        const key1 = key0[j]\n        this.log.debug({ msg: 'acd/storage/redis._invalidateReferences del key' + key1 })\n        removed.push(key1)\n        writes.push(['del', key1])\n      }\n    }\n\n    await this.store.pipeline(writes).exec()\n    await this.clearReferences(removed)\n    return removed\n  }\n\n  /**\n   * @param {string} reference\n   * @returns {string[]} removed keys\n   */\n  async _invalidateReference (reference) {\n    let keys\n    if (reference.includes('*')) {\n      const references = await this.store.keys(this.getReferenceKeyLabel(reference))\n      return this._invalidateReferences(references, false)\n    } else {\n      keys = await this.store.smembers(this.getReferenceKeyLabel(reference))\n    }\n\n    this.log.debug({ msg: 'acd/storage/redis._invalidateReference keys', keys })\n\n    const writes = []\n    const removed = []\n    for (let i = 0; i < keys.length; i++) {\n      const key0 = keys[i]\n      this.log.debug({ msg: 'acd/storage/redis._invalidateReference del key' + key0 })\n      removed.push(key0)\n      writes.push(['del', key0])\n    }\n\n    await this.store.pipeline(writes).exec()\n    await this.clearReferences(removed)\n    return removed\n  }\n\n  /**\n   * @param {string} name\n   */\n  async clear (name) {\n    this.log.debug({ msg: 'acd/storage/redis.clear', name })\n\n    try {\n      if (!name) {\n        await this.store.flushall()\n        return\n      }\n\n      const keys = await this.store.keys(`${name}*`)\n      this.log.debug({ msg: 'acd/storage/redis.clear keys', keys })\n\n      const removes = keys.map(key => ['del', key])\n      await this.store.pipeline(removes).exec()\n\n      if (!this.invalidation) { return }\n      await this.clearReferences(keys)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.clear error', err, name })\n    }\n  }\n\n  async refresh () {\n    try {\n      await this.store.flushall()\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.refresh error', err })\n    }\n  }\n\n  /**\n   * note: does not throw on error\n   * @param {string|string[]} keys\n   */\n  async clearReferences (keys) {\n    try {\n      if (!keys) {\n        this.log.warn({ msg: 'acd/storage/redis.clearReferences invalid call due to empty key' })\n        return\n      }\n\n      if (!Array.isArray(keys)) { keys = [keys] }\n\n      const reads = keys.map(key => ['smembers', this.getKeyReferenceLabel(key)])\n      const referencesKeys = await this.store.pipeline(reads).exec()\n\n      this.log.debug({ msg: 'acd/storage/redis.clearReferences references', keys, referencesKeys })\n\n      const writes = {}\n      for (let i = 0; i < keys.length; i++) {\n        for (let j = 0; j < referencesKeys[i][1].length; j++) {\n          const reference = this.getReferenceKeyLabel(referencesKeys[i][1][j])\n          if (writes[reference]) { continue }\n          writes[reference] = ['srem', reference, keys]\n        }\n        const key = this.getKeyReferenceLabel(keys[i])\n        writes[key] = ['del', key]\n      }\n\n      this.log.debug({ msg: 'acd/storage/redis.clearReferences writes pipeline', writes })\n      await this.store.pipeline(Object.values(writes)).exec()\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.clearReferences error', err })\n    }\n  }\n\n  /**\n   * scan references and clean expired/evicted keys\n   * @param {?string} [mode=lazy] lazy or strict\n   * - in lazy mode, only `options.max` references are scanned every time, picking keys to check randomly\n   *   so this operation is lighter while does not ensure references full clean up\n   * - in strict mode, all references and keys are checked\n   *   this operation scan the whole db and is slow\n   * @param {?object} options\n   * @param {number} [options.chunk=64] number of references to retrieve at once\n   * @param {number|undefined} [options.lazy.cursor] cursor to start the scan; should be last cursor returned by scan; default start from the beginning\n   * @param {number} [lazyChunk=64] number of references to check per gc cycle\n   * @return {Object} report information of the operation\n   *   references scanned/removed, keys scanned/removed, loops, cursor, error if any\n   */\n  async gc (mode = 'lazy', options = {}) {\n    this.log.debug({ msg: 'acd/storage/redis.gc', mode, options })\n\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/redis.gc does not run due to invalidation is disabled' })\n      return\n    }\n\n    if (mode !== 'strict' && mode !== 'lazy') { mode = 'lazy' }\n    const report = {\n      references: { scanned: [], removed: [] },\n      keys: { scanned: new Set(), removed: new Set() },\n      loops: 0,\n      cursor: 0,\n      error: null\n    }\n\n    try {\n      let cursor = 0\n      let lazyChunk = GC_DEFAULT_LAZY_CHUNK\n\n      if (options.chunk && (typeof options.chunk !== 'number' || options.chunk < 1)) {\n        report.error = new Error('chunk must be a positive integer greater than 1')\n        return report\n      }\n\n      if (options.lazy) {\n        if (options.lazy.chunk) {\n          if (typeof options.lazy.chunk !== 'number' || options.lazy.chunk < 1) {\n            report.error = new Error('lazy.chunk must be a positive integer greater than 1')\n            return report\n          }\n          lazyChunk = options.lazy.chunk\n        }\n        if (options.lazy.cursor) {\n          if (typeof options.lazy.cursor !== 'number' || options.lazy.cursor < 0) {\n            report.error = new Error('lazy.cursor must be a positive integer greater than 0')\n            return report\n          }\n          cursor = options.lazy.cursor\n        }\n      }\n\n      const chunk = options.chunk || GC_DEFAULT_CHUNK\n      const scanCount = Math.min(lazyChunk, chunk)\n      const startingCursor = cursor\n\n      let lastScanLength = -1\n      let lastRemoved = -1\n      do {\n        report.loops++\n\n        const scan = await this.store.scan(cursor, 'match', 'r:*', 'count', scanCount)\n        cursor = Number(scan[0])\n        lastScanLength = scan[1].length\n\n        const references = mode === 'lazy'\n          ? randomSubset(scan[1], lazyChunk)\n          : scan[1]\n\n        report.references.scanned = report.references.scanned.concat(references)\n\n        let reads = []\n        for (let i = 0; i < references.length; i++) {\n          const reference = references[i]\n          reads.push(['smembers', reference])\n        }\n        const referencesKeys = await this.store.pipeline(reads).exec()\n\n        const keysMap = {}\n        const referencesKeysMap = {}\n        for (let i = 0; i < referencesKeys.length; i++) {\n          const keys = referencesKeys[i]\n          const reference = references[i]\n          referencesKeysMap[reference] = keys[1]\n          for (let j = 0; j < keys[1].length; j++) {\n            const key = keys[1][j]\n            if (!keysMap[key]) {\n              keysMap[key] = [reference]\n            } else {\n              keysMap[key].push(reference)\n            }\n\n            report.keys.scanned.add(key)\n          }\n        }\n\n        const keys = Object.keys(keysMap)\n        reads = keys.map(key => ['exists', key])\n        const existingKeys = await this.store.pipeline(reads).exec()\n\n        const removingKeys = {}\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          if (existingKeys[i][1] === 1) { continue }\n\n          for (let j = 0; j < keysMap[key].length; j++) {\n            const reference = keysMap[key][j]\n            if (!removingKeys[reference]) {\n              removingKeys[reference] = [key]\n            } else {\n              removingKeys[reference].push(key)\n            }\n\n            report.keys.removed.add(key)\n          }\n        }\n\n        const writeReferences = Object.keys(removingKeys)\n        const writes = []\n        for (let i = 0; i < writeReferences.length; i++) {\n          const reference = writeReferences[i]\n          if (referencesKeysMap[reference].length === removingKeys[reference].length) {\n            writes.push(['del', reference])\n            report.references.removed.push(reference)\n          } else {\n            writes.push(['srem', reference, removingKeys[reference]])\n          }\n        }\n        await this.store.pipeline(writes).exec()\n        lastRemoved = writes.length\n\n        if (mode === 'lazy' && report.references.scanned.length >= lazyChunk) {\n          break\n        }\n      } while (startingCursor !== cursor && lastScanLength > 0 && lastRemoved > 0)\n\n      report.cursor = cursor\n      report.keys.scanned = Array.from(report.keys.scanned)\n      report.keys.removed = Array.from(report.keys.removed)\n    } catch (err) {\n      this.log.error({ msg: 'acd/storage/redis.gc error', err })\n      report.error = err\n    }\n    return report\n  }\n}\n\nmodule.exports = StorageRedis\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n  if (typeof next !== 'function')\n    throw new Error('obliterator/iterator: expecting a function!');\n\n  this.next = next;\n}\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function () {\n  var args = arguments,\n    l = args.length,\n    i = 0;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function () {\n  var iterator = new Iterator(function () {\n    return {done: true};\n  });\n\n  return iterator;\n};\n\n/**\n * Returning an iterator over the given indexed sequence.\n *\n * @param  {string|Array} sequence - Target sequence.\n * @return {Iterator}\n */\nIterator.fromSequence = function (sequence) {\n  var i = 0,\n    l = sequence.length;\n\n  return new Iterator(function () {\n    if (i >= l) return {done: true};\n\n    return {done: false, value: sequence[i++]};\n  });\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function (value) {\n  if (value instanceof Iterator) return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';\nexports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';\n","/**\n * Obliterator ForEach Function\n * =============================\n *\n * Helper function used to easily iterate over mixed values.\n */\nvar support = require('./support.js');\n\nvar ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;\nvar SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;\n\n/**\n * Function able to iterate over almost any iterable JS value.\n *\n * @param  {any}      iterable - Iterable value.\n * @param  {function} callback - Callback function.\n */\nmodule.exports = function forEach(iterable, callback) {\n  var iterator, k, i, l, s;\n\n  if (!iterable) throw new Error('obliterator/forEach: invalid iterable.');\n\n  if (typeof callback !== 'function')\n    throw new Error('obliterator/forEach: expecting a callback.');\n\n  // The target is an array or a string or function arguments\n  if (\n    Array.isArray(iterable) ||\n    (ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable)) ||\n    typeof iterable === 'string' ||\n    iterable.toString() === '[object Arguments]'\n  ) {\n    for (i = 0, l = iterable.length; i < l; i++) callback(iterable[i], i);\n    return;\n  }\n\n  // The target has a #.forEach method\n  if (typeof iterable.forEach === 'function') {\n    iterable.forEach(callback);\n    return;\n  }\n\n  // The target is iterable\n  if (\n    SYMBOL_SUPPORT &&\n    Symbol.iterator in iterable &&\n    typeof iterable.next !== 'function'\n  ) {\n    iterable = iterable[Symbol.iterator]();\n  }\n\n  // The target is an iterator\n  if (typeof iterable.next === 'function') {\n    iterator = iterable;\n    i = 0;\n\n    while (((s = iterator.next()), s.done !== true)) {\n      callback(s.value, i);\n      i++;\n    }\n\n    return;\n  }\n\n  // The target is a plain object\n  for (k in iterable) {\n    if (iterable.hasOwnProperty(k)) {\n      callback(iterable[k], k);\n    }\n  }\n\n  return;\n};\n","/**\n * Mnemonist Typed Array Helpers\n * ==============================\n *\n * Miscellaneous helpers related to typed arrays.\n */\n\n/**\n * When using an unsigned integer array to store pointers, one might want to\n * choose the optimal word size in regards to the actual numbers of pointers\n * to store.\n *\n * This helpers does just that.\n *\n * @param  {number} size - Expected size of the array to map.\n * @return {TypedArray}\n */\nvar MAX_8BIT_INTEGER = Math.pow(2, 8) - 1,\n    MAX_16BIT_INTEGER = Math.pow(2, 16) - 1,\n    MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;\n\nvar MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1,\n    MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1,\n    MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;\n\nexports.getPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_8BIT_INTEGER)\n    return Uint8Array;\n\n  if (maxIndex <= MAX_16BIT_INTEGER)\n    return Uint16Array;\n\n  if (maxIndex <= MAX_32BIT_INTEGER)\n    return Uint32Array;\n\n  throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');\n};\n\nexports.getSignedPointerArray = function(size) {\n  var maxIndex = size - 1;\n\n  if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)\n    return Int8Array;\n\n  if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)\n    return Int16Array;\n\n  if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)\n    return Int32Array;\n\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given number.\n *\n * @param  {number} value - Value to test.\n * @return {TypedArrayClass}\n */\nexports.getNumberType = function(value) {\n\n  // <= 32 bits itnteger?\n  if (value === (value | 0)) {\n\n    // Negative\n    if (Math.sign(value) === -1) {\n      if (value <= 127 && value >= -128)\n        return Int8Array;\n\n      if (value <= 32767 && value >= -32768)\n        return Int16Array;\n\n      return Int32Array;\n    }\n    else {\n\n      if (value <= 255)\n        return Uint8Array;\n\n      if (value <= 65535)\n        return Uint16Array;\n\n      return Uint32Array;\n    }\n  }\n\n  // 53 bits integer & floats\n  // NOTE: it's kinda hard to tell whether we could use 32bits or not...\n  return Float64Array;\n};\n\n/**\n * Function returning the minimal type able to represent the given array\n * of JavaScript numbers.\n *\n * @param  {array}    array  - Array to represent.\n * @param  {function} getter - Optional getter.\n * @return {TypedArrayClass}\n */\nvar TYPE_PRIORITY = {\n  Uint8Array: 1,\n  Int8Array: 2,\n  Uint16Array: 3,\n  Int16Array: 4,\n  Uint32Array: 5,\n  Int32Array: 6,\n  Float32Array: 7,\n  Float64Array: 8\n};\n\n// TODO: make this a one-shot for one value\nexports.getMinimalRepresentation = function(array, getter) {\n  var maxType = null,\n      maxPriority = 0,\n      p,\n      t,\n      v,\n      i,\n      l;\n\n  for (i = 0, l = array.length; i < l; i++) {\n    v = getter ? getter(array[i]) : array[i];\n    t = exports.getNumberType(v);\n    p = TYPE_PRIORITY[t.name];\n\n    if (p > maxPriority) {\n      maxPriority = p;\n      maxType = t;\n    }\n  }\n\n  return maxType;\n};\n\n/**\n * Function returning whether the given value is a typed array.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nexports.isTypedArray = function(value) {\n  return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);\n};\n\n/**\n * Function used to concat byte arrays.\n *\n * @param  {...ByteArray}\n * @return {ByteArray}\n */\nexports.concat = function() {\n  var length = 0,\n      i,\n      o,\n      l;\n\n  for (i = 0, l = arguments.length; i < l; i++)\n    length += arguments[i].length;\n\n  var array = new (arguments[0].constructor)(length);\n\n  for (i = 0, o = 0; i < l; i++) {\n    array.set(arguments[i], o);\n    o += arguments[i].length;\n  }\n\n  return array;\n};\n\n/**\n * Function used to initialize a byte array of indices.\n *\n * @param  {number}    length - Length of target.\n * @return {ByteArray}\n */\nexports.indices = function(length) {\n  var PointerArray = exports.getPointerArray(length);\n\n  var array = new PointerArray(length);\n\n  for (var i = 0; i < length; i++)\n    array[i] = i;\n\n  return array;\n};\n","/**\n * Mnemonist Iterable Function\n * ============================\n *\n * Harmonized iteration helpers over mixed iterable targets.\n */\nvar forEach = require('obliterator/foreach');\n\nvar typed = require('./typed-arrays.js');\n\n/**\n * Function used to determine whether the given object supports array-like\n * random access.\n *\n * @param  {any} target - Target object.\n * @return {boolean}\n */\nfunction isArrayLike(target) {\n  return Array.isArray(target) || typed.isTypedArray(target);\n}\n\n/**\n * Function used to guess the length of the structure over which we are going\n * to iterate.\n *\n * @param  {any} target - Target object.\n * @return {number|undefined}\n */\nfunction guessLength(target) {\n  if (typeof target.length === 'number')\n    return target.length;\n\n  if (typeof target.size === 'number')\n    return target.size;\n\n  return;\n}\n\n/**\n * Function used to convert an iterable to an array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArray(target) {\n  var l = guessLength(target);\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i++] = value;\n  });\n\n  return array;\n}\n\n/**\n * Same as above but returns a supplementary indices array.\n *\n * @param  {any}   target - Iteration target.\n * @return {array}\n */\nfunction toArrayWithIndices(target) {\n  var l = guessLength(target);\n\n  var IndexArray = typeof l === 'number' ?\n    typed.getPointerArray(l) :\n    Array;\n\n  var array = typeof l === 'number' ? new Array(l) : [];\n  var indices = typeof l === 'number' ? new IndexArray(l) : [];\n\n  var i = 0;\n\n  // TODO: we could optimize when given target is array like\n  forEach(target, function(value) {\n    array[i] = value;\n    indices[i] = i++;\n  });\n\n  return [array, indices];\n}\n\n/**\n * Exporting.\n */\nexports.isArrayLike = isArrayLike;\nexports.guessLength = guessLength;\nexports.toArray = toArray;\nexports.toArrayWithIndices = toArrayWithIndices;\n","/**\n * Mnemonist LRUCache\n * ===================\n *\n * JavaScript implementation of the LRU Cache data structure. To save up\n * memory and allocations this implementation represents its underlying\n * doubly-linked list as static arrays and pointers. Thus, memory is allocated\n * only once at instantiation and JS objects are never created to serve as\n * pointers. This also means this implementation does not trigger too many\n * garbage collections.\n *\n * Note that to save up memory, a LRU Cache can be implemented using a singly\n * linked list by storing predecessors' pointers as hashmap values.\n * However, this means more hashmap lookups and would probably slow the whole\n * thing down. What's more, pointers are not the things taking most space in\n * memory.\n */\nvar Iterator = require('obliterator/iterator'),\n    forEach = require('obliterator/foreach'),\n    typed = require('./utils/typed-arrays.js'),\n    iterables = require('./utils/iterables.js');\n\n/**\n * LRUCache.\n *\n * @constructor\n * @param {function} Keys     - Array class for storing keys.\n * @param {function} Values   - Array class for storing values.\n * @param {number}   capacity - Desired capacity.\n */\nfunction LRUCache(Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  this.capacity = capacity;\n\n  if (typeof this.capacity !== 'number' || this.capacity <= 0)\n    throw new Error('mnemonist/lru-cache: capacity should be positive number.');\n  else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity)\n    throw new Error('mnemonist/lru-cache: capacity should be a finite positive integer.');\n\n  var PointerArray = typed.getPointerArray(capacity);\n\n  this.forward = new PointerArray(capacity);\n  this.backward = new PointerArray(capacity);\n  this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);\n  this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);\n\n  // Properties\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n}\n\n/**\n * Method used to clear the structure.\n *\n * @return {undefined}\n */\nLRUCache.prototype.clear = function() {\n  this.size = 0;\n  this.head = 0;\n  this.tail = 0;\n  this.items = {};\n};\n\n/**\n * Method used to splay a value on top.\n *\n * @param  {number}   pointer - Pointer of the value to splay on top.\n * @return {LRUCache}\n */\nLRUCache.prototype.splayOnTop = function(pointer) {\n  var oldHead = this.head;\n\n  if (this.head === pointer)\n    return this;\n\n  var previous = this.backward[pointer],\n      next = this.forward[pointer];\n\n  if (this.tail === pointer) {\n    this.tail = previous;\n  }\n  else {\n    this.backward[next] = previous;\n  }\n\n  this.forward[previous] = next;\n\n  this.backward[oldHead] = pointer;\n  this.head = pointer;\n  this.forward[pointer] = oldHead;\n\n  return this;\n};\n\n/**\n * Method used to set the value for the given key in the cache.\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {undefined}\n */\nLRUCache.prototype.set = function(key, value) {\n\n  var pointer = this.items[key];\n\n  // The key already exists, we just need to update the value and splay on top\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    this.V[pointer] = value;\n\n    return;\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    delete this.items[this.K[pointer]];\n  }\n\n  // Storing key & value\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n};\n\n/**\n * Method used to set the value for the given key in the cache\n *\n * @param  {any} key   - Key.\n * @param  {any} value - Value.\n * @return {{evicted: boolean, key: any, value: any}} An object containing the\n * key and value of an item that was overwritten or evicted in the set\n * operation, as well as a boolean indicating whether it was evicted due to\n * limited capacity. Return value is null if nothing was evicted or overwritten\n * during the set operation.\n */\nLRUCache.prototype.setpop = function(key, value) {\n  var oldValue = null;\n  var oldKey = null;\n\n  var pointer = this.items[key];\n\n  // The key already exists, we just need to update the value and splay on top\n  if (typeof pointer !== 'undefined') {\n    this.splayOnTop(pointer);\n    oldValue = this.V[pointer];\n    this.V[pointer] = value;\n    return {evicted: false, key: key, value: oldValue};\n  }\n\n  // The cache is not yet full\n  if (this.size < this.capacity) {\n    pointer = this.size++;\n  }\n\n  // Cache is full, we need to drop the last value\n  else {\n    pointer = this.tail;\n    this.tail = this.backward[pointer];\n    oldValue = this.V[pointer];\n    oldKey = this.K[pointer];\n    delete this.items[oldKey];\n  }\n\n  // Storing key & value\n  this.items[key] = pointer;\n  this.K[pointer] = key;\n  this.V[pointer] = value;\n\n  // Moving the item at the front of the list\n  this.forward[pointer] = this.head;\n  this.backward[this.head] = pointer;\n  this.head = pointer;\n\n  // Return object if eviction took place, otherwise return null\n  if (oldKey) {\n    return {evicted: true, key: oldKey, value: oldValue};\n  }\n  else {\n    return null;\n  }\n};\n\n/**\n * Method used to check whether the key exists in the cache.\n *\n * @param  {any} key   - Key.\n * @return {boolean}\n */\nLRUCache.prototype.has = function(key) {\n  return key in this.items;\n};\n\n/**\n * Method used to get the value attached to the given key. Will move the\n * related key to the front of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUCache.prototype.get = function(key) {\n  var pointer = this.items[key];\n\n  if (typeof pointer === 'undefined')\n    return;\n\n  this.splayOnTop(pointer);\n\n  return this.V[pointer];\n};\n\n/**\n * Method used to get the value attached to the given key. Does not modify\n * the ordering of the underlying linked list.\n *\n * @param  {any} key   - Key.\n * @return {any}\n */\nLRUCache.prototype.peek = function(key) {\n  var pointer = this.items[key];\n\n  if (typeof pointer === 'undefined')\n    return;\n\n  return this.V[pointer];\n};\n\n/**\n * Method used to iterate over the cache's entries using a callback.\n *\n * @param  {function}  callback - Function to call for each item.\n * @param  {object}    scope    - Optional scope.\n * @return {undefined}\n */\nLRUCache.prototype.forEach = function(callback, scope) {\n  scope = arguments.length > 1 ? scope : this;\n\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n\n  while (i < l) {\n\n    callback.call(scope, values[pointer], keys[pointer], this);\n    pointer = forward[pointer];\n\n    i++;\n  }\n};\n\n/**\n * Method used to create an iterator over the cache's keys from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.keys = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var key = keys[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: key\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the cache's values from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.values = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      values = this.V,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var value = values[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: value\n    };\n  });\n};\n\n/**\n * Method used to create an iterator over the cache's entries from most\n * recently used to least recently used.\n *\n * @return {Iterator}\n */\nLRUCache.prototype.entries = function() {\n  var i = 0,\n      l = this.size;\n\n  var pointer = this.head,\n      keys = this.K,\n      values = this.V,\n      forward = this.forward;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    var key = keys[pointer],\n        value = values[pointer];\n\n    i++;\n\n    if (i < l)\n      pointer = forward[pointer];\n\n    return {\n      done: false,\n      value: [key, value]\n    };\n  });\n};\n\n/**\n * Attaching the #.entries method to Symbol.iterator if possible.\n */\nif (typeof Symbol !== 'undefined')\n  LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;\n\n/**\n * Convenience known methods.\n */\nLRUCache.prototype.inspect = function() {\n  var proxy = new Map();\n\n  var iterator = this.entries(),\n      step;\n\n  while ((step = iterator.next(), !step.done))\n    proxy.set(step.value[0], step.value[1]);\n\n  // Trick so that node displays the name of the constructor\n  Object.defineProperty(proxy, 'constructor', {\n    value: LRUCache,\n    enumerable: false\n  });\n\n  return proxy;\n};\n\nif (typeof Symbol !== 'undefined')\n  LRUCache.prototype[Symbol.for('nodejs.util.inspect.custom')] = LRUCache.prototype.inspect;\n\n/**\n * Static @.from function taking an arbitrary iterable & converting it into\n * a structure.\n *\n * @param  {Iterable} iterable - Target iterable.\n * @param  {function} Keys     - Array class for storing keys.\n * @param  {function} Values   - Array class for storing values.\n * @param  {number}   capacity - Cache's capacity.\n * @return {LRUCache}\n */\nLRUCache.from = function(iterable, Keys, Values, capacity) {\n  if (arguments.length < 2) {\n    capacity = iterables.guessLength(iterable);\n\n    if (typeof capacity !== 'number')\n      throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');\n  }\n  else if (arguments.length === 2) {\n    capacity = Keys;\n    Keys = null;\n    Values = null;\n  }\n\n  var cache = new LRUCache(Keys, Values, capacity);\n\n  forEach(iterable, function(value, key) {\n    cache.set(key, value);\n  });\n\n  return cache;\n};\n\n/**\n * Exporting.\n */\nmodule.exports = LRUCache;\n","'use strict'\n\nconst LRUCache = require('mnemonist/lru-cache')\nconst { abstractLogging } = require('../util')\nconst StorageInterface = require('./interface')\nconst { findMatchingIndexes, findNotMatching, bsearchIndex, wildcardMatch } = require('../util')\n\n/* c8 ignore next */\nconst setImmediate = typeof globalThis.setImmediate !== 'undefined' ? globalThis.setImmediate : (fn, ...args) => setTimeout(fn, 0, ...args)\n\nconst DEFAULT_CACHE_SIZE = 1024\n\n/**\n * @typedef StorageMemoryOptions\n * @property {?number} [size=1024]\n * @property {?Logger} [log]\n * @property {?boolean} [invalidation=false]\n */\n\nclass StorageMemory extends StorageInterface {\n  /**\n   * in-memory storage\n   * @param {StorageMemoryOptions} options\n   */\n  constructor (options = {}) {\n    if (options.size && (typeof options.size !== 'number' || options.size < 1)) {\n      throw new Error('size must be a positive integer greater than 0')\n    }\n\n    super(options)\n    this.size = options.size || DEFAULT_CACHE_SIZE\n    this.log = options.log || abstractLogging()\n    this.invalidation = options.invalidation || false\n\n    this.init()\n  }\n\n  init () {\n    this.store = new LRUCache(this.size)\n\n    if (!this.invalidation) {\n      return\n    }\n    // key -> references, keys are strings, references are sorted array strings\n    this.keysReferences = new Map()\n    // same as above, but inverted\n    this.referencesKeys = new Map()\n  }\n\n  /**\n   * retrieve the value by key\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found or expired\n   */\n  get (key) {\n    this.log.debug({ msg: 'acd/storage/memory.get', key })\n\n    const entry = this.store.get(key)\n    if (entry) {\n      this.log.debug({ msg: 'acd/storage/memory.get, entry', entry, now: now() })\n      if (entry.start + entry.ttl > now()) {\n        this.log.debug({ msg: 'acd/storage/memory.get, key is NOT expired', key, entry })\n        return entry.value\n      }\n      this.log.debug({ msg: 'acd/storage/memory.get, key is EXPIRED', key, entry })\n\n      // no need to wait for key to be removed\n\n      setImmediate(() => this.remove(key))\n    }\n  }\n\n  /**\n   * retrieve the remaining TTL value by key\n   * @param {string} key\n   * @returns {undefined|*} undefined if key not found or expired\n   */\n  getTTL (key) {\n    this.log.debug({ msg: 'acd/storage/memory.getTTL', key })\n\n    const entry = this.store.peek(key)\n    let ttl = 0\n    if (entry) {\n      ttl = entry.start + entry.ttl - now()\n      if (ttl < 0) {\n        ttl = 0\n      }\n    }\n\n    return ttl\n  }\n\n  /**\n   * set value by key\n   * @param {string} key\n   * @param {*} value\n   * @param {?number} [ttl=0] - ttl in seconds; zero means key will not be stored\n   * @param {?string[]} references\n   */\n  set (key, value, ttl, references) {\n    this.log.debug({ msg: 'acd/storage/memory.set', key, value, ttl, references })\n\n    ttl = Number(ttl)\n    if (!ttl || ttl < 0) {\n      return\n    }\n    const existingKey = this.store.has(key)\n    const removed = this.store.setpop(key, { value, ttl, start: now() })\n    this.log.debug({ msg: 'acd/storage/memory.set, evicted', removed })\n    if (removed && removed.evicted) {\n      this.log.debug({ msg: 'acd/storage/memory.set, remove evicted key', key: removed.key })\n      this._removeReferences([removed.key])\n    }\n\n    if (!references || references.length < 1) {\n      return\n    }\n\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/memory.set, invalidation is disabled, references are useless' })\n      return\n    }\n\n    // references must be unique\n    references = [...new Set(references)]\n\n    // clear old references\n    let currentReferences\n    if (existingKey) {\n      currentReferences = this.keysReferences.get(key)\n      this.log.debug({ msg: 'acd/storage/memory.set, current keys-references', key, references: currentReferences })\n      if (currentReferences) {\n        currentReferences.sort()\n        references.sort()\n        const referencesToRemove = findNotMatching(references, currentReferences)\n\n        // remove key in old references\n        for (const reference of referencesToRemove) {\n          const keys = this.referencesKeys.get(reference)\n          /* c8 ignore next */\n          if (!keys) { continue }\n          const index = bsearchIndex(keys, key)\n          /* c8 ignore next */\n          if (index < 0) { continue }\n          keys.splice(index, 1)\n\n          if (keys.length < 1) {\n            this.referencesKeys.delete(reference)\n            continue\n          }\n          this.referencesKeys.set(reference, keys)\n        }\n      }\n    }\n\n    // TODO we can probably get referencesToAdd and referencesToRemove in a single loop\n    const referencesToAdd = currentReferences ? findNotMatching(currentReferences, references) : references\n\n    for (let i = 0; i < referencesToAdd.length; i++) {\n      const reference = referencesToAdd[i]\n      let keys = this.referencesKeys.get(reference)\n      if (keys) {\n        this.log.debug({ msg: 'acd/storage/memory.set, add reference-key', key, reference })\n        keys.push(key)\n      } else {\n        keys = [key]\n      }\n      this.log.debug({ msg: 'acd/storage/memory.set, set reference-keys', keys, reference })\n      this.referencesKeys.set(reference, keys)\n    }\n\n    this.keysReferences.set(key, references)\n  }\n\n  /**\n   * remove an entry by key\n   * @param {string} key\n   * @returns {boolean} indicates if key was removed\n   */\n  remove (key) {\n    this.log.debug({ msg: 'acd/storage/memory.remove', key })\n\n    const removed = this._removeKey(key)\n    this._removeReferences([key])\n    return removed\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  _removeKey (key) {\n    this.log.debug({ msg: 'acd/storage/memory._removeKey', key })\n    if (!this.store.has(key)) {\n      return false\n    }\n    this.store.set(key, undefined)\n    return true\n  }\n\n  /**\n   * @param {string[]} keys\n   */\n  _removeReferences (keys) {\n    if (!this.invalidation) {\n      return\n    }\n    this.log.debug({ msg: 'acd/storage/memory._removeReferences', keys })\n\n    const referencesToRemove = new Set()\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i]\n\n      const references = this.keysReferences.get(key)\n      if (!references) {\n        continue\n      }\n\n      for (let j = 0; j < references.length; j++) {\n        referencesToRemove.add(references[j])\n      }\n\n      this.log.debug({ msg: 'acd/storage/memory._removeReferences, delete key-references', key })\n      this.keysReferences.delete(key)\n    }\n\n    this._removeReferencesKeys([...referencesToRemove], keys)\n  }\n\n  /**\n   * @param {!string[]} references\n   * @param {string[]} keys\n   */\n  _removeReferencesKeys (references, keys) {\n    keys.sort()\n    this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys', references, keys })\n    for (let i = 0; i < references.length; i++) {\n      const reference = references[i]\n      // working on the original stored array\n      const referencesKeys = this.referencesKeys.get(reference)\n      this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, get reference-key', reference, keys, referencesKeys })\n      /* c8 ignore next */\n      if (!referencesKeys) continue\n\n      const referencesToRemove = findMatchingIndexes(keys, referencesKeys)\n      // cannot happen that referencesToRemove is empty\n      // because this function is triggered only by _removeReferences\n      // and \"keys\" are from tis.keyReferences\n      // if (referencesToRemove.length < 1) { continue }\n\n      this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, removing', reference, referencesToRemove, referencesKeys })\n\n      if (referencesToRemove.length === referencesKeys.length) {\n        this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, delete', reference })\n        this.referencesKeys.delete(reference)\n        continue\n      }\n\n      for (let j = referencesToRemove.length - 1; j >= 0; j--) {\n        this.log.debug({ msg: 'acd/storage/memory._removeReferencesKeys, remove', reference, referencesKeys, at: referencesToRemove[j] })\n        referencesKeys.splice(referencesToRemove[j], 1)\n      }\n    }\n  }\n\n  /**\n   * @param {string|string[]} references\n   * @returns {string[]} removed keys\n   */\n  invalidate (references) {\n    if (!this.invalidation) {\n      this.log.warn({ msg: 'acd/storage/memory.invalidate, exit due invalidation is disabled' })\n      return []\n    }\n\n    this.log.debug({ msg: 'acd/storage/memory.invalidate', references })\n\n    if (Array.isArray(references)) {\n      return this._invalidateReferences(references)\n    }\n    return this._invalidateReference(references)\n  }\n\n  /**\n   * @param {string[]} references\n   * @returns {string[]} removed keys\n   */\n  _invalidateReferences (references) {\n    const removed = []\n    for (let i = 0; i < references.length; i++) {\n      const reference = references[i]\n      const keys = this.referencesKeys.get(reference)\n      this.log.debug({ msg: 'acd/storage/memory._invalidateReferences, remove keys on reference', reference, keys })\n      if (!keys) {\n        continue\n      }\n\n      for (let j = 0; j < keys.length; j++) {\n        const key = keys[j]\n        this.log.debug({ msg: 'acd/storage/memory._invalidateReferences, remove key on reference', reference, key })\n        if (this._removeKey(key)) {\n          removed.push(key)\n        }\n      }\n\n      this.log.debug({ msg: 'acd/storage/memory._invalidateReferences, remove references of', reference, keys })\n      this._removeReferences([...keys])\n    }\n\n    return removed\n  }\n\n  /**\n   * @param {string} reference\n   * @returns {string[]} removed keys\n   */\n  _invalidateReference (reference) {\n    if (reference.includes('*')) {\n      const references = []\n      for (const key of this.referencesKeys.keys()) {\n        if (wildcardMatch(reference, key)) {\n          references.push(key)\n        }\n      }\n      return this._invalidateReferences(references)\n    }\n\n    const keys = this.referencesKeys.get(reference)\n    const removed = []\n    this.log.debug({ msg: 'acd/storage/memory._invalidateReference, remove keys on reference', reference, keys })\n\n    if (!keys) {\n      return removed\n    }\n\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j]\n      this.log.debug({ msg: 'acd/storage/memory._invalidateReference, remove key on reference', reference, key })\n      if (this._removeKey(key)) {\n        removed.push(key)\n      }\n    }\n\n    this.log.debug({ msg: 'acd/storage/memory._invalidateReference, remove references of', reference, keys })\n    this._removeReferences([...keys])\n\n    return removed\n  }\n\n  /**\n   * remove all entries if name is not provided\n   * remove entries where key starts with name if provided\n   * @param {?string} name\n   * @return {string[]} removed keys\n   */\n  clear (name) {\n    this.log.debug({ msg: 'acd/storage/memory.clear', name })\n\n    if (!name) {\n      this.store.clear()\n      if (!this.invalidation) { return }\n      this.referencesKeys.clear()\n      this.keysReferences.clear()\n      return\n    }\n\n    const keys = []\n    this.store.forEach((value, key) => {\n      this.log.debug({ msg: 'acd/storage/memory.clear, iterate key', key })\n      if (key.indexOf(name) === 0) {\n        this.log.debug({ msg: 'acd/storage/memory.clear, remove key', key })\n        // can't remove here or the loop won't work\n        keys.push(key)\n      }\n    })\n\n    const removed = []\n    // remove all keys at first, then references\n    for (let i = 0; i < keys.length; i++) {\n      if (this._removeKey(keys[i])) {\n        removed.push(keys[i])\n      }\n    }\n\n    this._removeReferences(removed)\n\n    return removed\n  }\n\n  refresh () {\n    this.log.debug({ msg: 'acd/storage/memory.refresh' })\n\n    this.init()\n  }\n}\n\nlet _timer\n\nfunction now () {\n  if (_timer !== undefined) {\n    return _timer\n  }\n  _timer = Math.floor(Date.now() / 1000)\n  const timeout = setTimeout(_clearTimer, 1000)\n  if (typeof timeout.unref === 'function') timeout.unref()\n  return _timer\n}\n\nfunction _clearTimer () {\n  _timer = undefined\n}\n\nmodule.exports = StorageMemory\n","'use strict'\n\nconst { isServerSide } = require('../util')\n\nlet StorageRedis\nif (isServerSide) {\n  StorageRedis = require('./redis')\n}\nconst StorageMemory = require('./memory')\n\n/**\n * @typedef {StorageInterface} Storage\n */\n\n/**\n * @enum {string}\n */\nconst StorageOptionsType = {\n  redis: 'redis',\n  memory: 'memory'\n}\n\n/**\n * @typedef {Object} StorageOptions\n * @property {StorageOptionsType} type\n */\n\n/**\n * factory for storage, depending on type\n * @param {StorageOptionsType} type\n * @param {StorageMemoryOptions|StorageRedisOptions} options\n * @returns {StorageMemory|StorageRedis}\n */\nfunction createStorage (type, options) {\n  if (!isServerSide && type === StorageOptionsType.redis) {\n    throw new Error('Redis storage is not supported in the browser')\n  }\n\n  if (type === StorageOptionsType.redis) {\n    return new StorageRedis(options)\n  }\n  return new StorageMemory(options)\n}\n\nmodule.exports = createStorage\n","'use strict'\n\nconst { kValues, kStorage, kStorages, kTransfromer, kTTL, kOnDedupe, kOnError, kOnHit, kOnMiss, kStale } = require('./symbol')\nconst stringify = require('safe-stable-stringify')\nconst createStorage = require('./storage')\n\nclass Cache {\n  /**\n   * @param {!Object} opts\n   * @param {!Storage} opts.storage - the storage to use\n   * @param {?Object} opts.transformer - the transformer to use\n   * @param {?number} [opts.ttl=0] - in seconds; default is 0 seconds, so it only does dedupe without cache\n   * @param {?function} opts.onDedupe\n   * @param {?function} opts.onError\n   * @param {?function} opts.onHit\n   * @param {?function} opts.onMiss\n   */\n  constructor (options = {}) {\n    if (!options.storage) {\n      throw new Error('storage is required')\n    }\n\n    // ttl _may_ be a function to defer the ttl decision until later\n    if (options.ttl && typeof options.ttl === 'number' && (options.ttl < 0 || !Number.isInteger(options.ttl))) {\n      throw new Error('ttl must be a positive integer greater than 0')\n    }\n\n    if (options.onDedupe && typeof options.onDedupe !== 'function') {\n      throw new Error('onDedupe must be a function')\n    }\n\n    if (options.onError && typeof options.onError !== 'function') {\n      throw new Error('onError must be a function')\n    }\n\n    if (options.onHit && typeof options.onHit !== 'function') {\n      throw new Error('onHit must be a function')\n    }\n\n    if (options.onMiss && typeof options.onMiss !== 'function') {\n      throw new Error('onMiss must be a function')\n    }\n\n    // stale _may_ be a function to defer the stale decision until later\n    if (typeof options.stale === 'number' && !(Math.floor(options.stale) === options.stale && options.stale >= 0)) {\n      throw new Error('stale must be an integer greater or equal to 0')\n    }\n\n    this[kValues] = {}\n\n    this[kStorage] = options.storage\n    this[kStorages] = new Map()\n    this[kStorages].set('_default', options.storage)\n\n    this[kTransfromer] = options.transformer\n\n    this[kTTL] = options.ttl || 0\n    this[kOnDedupe] = options.onDedupe || noop\n    this[kOnError] = options.onError || noop\n    this[kOnHit] = options.onHit || noop\n    this[kOnMiss] = options.onMiss || noop\n    this[kStale] = options.stale || 0\n  }\n\n  /**\n   * add a new function to dedupe (and cache)\n   * @param {!string} name name of the function\n   * @param {?Object} [opts]\n   * @param {?Object} [opts.storage] storage to use; default is the main one\n   * @param {?Object} opts.transformer - the transformer to use\n   * @param {?number} [opts.ttl] ttl for the results; default ttl is the one passed to the constructor\n   * @param {?function} [opts.onDedupe] function to call on dedupe; default is the one passed to the constructor\n   * @param {?function} [opts.onError] function to call on error; default is the one passed to the constructor\n   * @param {?function} [opts.onHit] function to call on hit; default is the one passed to the constructor\n   * @param {?function} [opts.onMiss] function to call on miss; default is the one passed to the constructor\n   * @param {?function} [opts.serialize] custom function to serialize the arguments of `func`, in order to create the key for deduping and caching\n   * @param {?function} [opts.references] function to generate references\n   * @param {!function} func the function to dedupe (and cache)\n   **/\n  define (name, opts, func) {\n    if (typeof opts === 'function') {\n      func = opts\n      opts = {}\n    }\n\n    if (name && this[name]) {\n      throw new Error(`${name} is already defined in the cache or it is a forbidden name`)\n    }\n\n    opts = opts || {}\n\n    if (typeof func !== 'function') {\n      throw new TypeError(`Missing the function parameter for '${name}'`)\n    }\n\n    const serialize = opts.serialize\n    if (serialize && typeof serialize !== 'function') {\n      throw new TypeError('serialize must be a function')\n    }\n\n    const references = opts.references\n    if (references && typeof references !== 'function') {\n      throw new TypeError('references must be a function')\n    }\n\n    if (typeof opts.ttl !== 'function') {\n      if (opts.ttl && (typeof opts.ttl !== 'number' || opts.ttl < 0 || !Number.isInteger(opts.ttl))) {\n        throw new Error('ttl must be a positive integer greater than 0')\n      }\n    }\n\n    let storage\n    if (opts.storage) {\n      storage = createStorage(opts.storage.type, opts.storage.options)\n      this[kStorages].set(name, storage)\n    } else {\n      storage = this[kStorage]\n    }\n\n    const ttl = opts.ttl !== undefined ? opts.ttl : this[kTTL]\n    const stale = opts.stale !== undefined ? opts.stale : this[kStale]\n    const onDedupe = opts.onDedupe || this[kOnDedupe]\n    const onError = opts.onError || this[kOnError]\n    const onHit = opts.onHit || this[kOnHit]\n    const onMiss = opts.onMiss || this[kOnMiss]\n    const transformer = opts.transformer || this[kTransfromer]\n\n    const wrapper = new Wrapper(func, name, serialize, references, storage, transformer, ttl, onDedupe, onError, onHit, onMiss, stale)\n\n    this[kValues][name] = wrapper\n    this[name] = wrapper.add.bind(wrapper)\n    return this\n  }\n\n  async clear (name, value) {\n    if (name) {\n      if (!this[kValues][name]) {\n        throw new Error(`${name} is not defined in the cache`)\n      }\n\n      await this[kValues][name].clear(value)\n      return\n    }\n\n    const clears = []\n    for (const wrapper of Object.values(this[kValues])) {\n      clears.push(wrapper.clear())\n    }\n    await Promise.all(clears)\n  }\n\n  async get (name, key) {\n    if (!this[kValues][name]) {\n      throw new Error(`${name} is not defined in the cache`)\n    }\n\n    // TODO validate key?\n\n    return this[kValues][name].get(key)\n  }\n\n  async set (name, key, value, ttl, references) {\n    if (!this[kValues][name]) {\n      throw new Error(`${name} is not defined in the cache`)\n    }\n\n    // TODO validate key, value, ttl, references?\n\n    return this[kValues][name].set(key, value, ttl, references)\n  }\n\n  async invalidate (name, references) {\n    if (!this[kValues][name]) {\n      throw new Error(`${name} is not defined in the cache`)\n    }\n\n    return this[kValues][name].invalidate(references)\n  }\n\n  async invalidateAll (references, storage = '_default') {\n    if (!this[kStorages].has(storage)) {\n      throw new Error(`${storage} storage is not defined in the cache`)\n    }\n    const s = this[kStorages].get(storage)\n    await s.invalidate(references)\n  }\n}\n\nclass Wrapper {\n  /**\n   * @param {function} func\n   * @param {string} name\n   * @param {function} serialize\n   * @param {function} references\n   * @param {Storage} storage\n   * @param {Object} transformer\n   * @param {number} ttl\n   * @param {function} onDedupe\n   * @param {function} onError\n   * @param {function} onHit\n   * @param {function} onMiss\n   * @param {stale} ttl\n   */\n  constructor (func, name, serialize, references, storage, transformer, ttl, onDedupe, onError, onHit, onMiss, stale) {\n    this.dedupes = new Map()\n    this.func = func\n    this.name = name\n    this.serialize = serialize\n    this.references = references\n\n    this.storage = storage\n    this.transformer = transformer\n    this.ttl = ttl\n    this.onDedupe = onDedupe\n    this.onError = onError\n    this.onHit = onHit\n    this.onMiss = onMiss\n    this.stale = stale\n  }\n\n  getKey (args) {\n    const id = this.serialize ? this.serialize(args) : args\n    return typeof id === 'string' ? id : stringify(id)\n  }\n\n  getStorageKey (key) {\n    return `${this.name}~${key}`\n  }\n\n  getStorageName () {\n    return `${this.name}~`\n  }\n\n  add (args) {\n    try {\n      const key = this.getKey(args)\n\n      let query = this.dedupes.get(key)\n      if (!query) {\n        query = new Query()\n        this.buildPromise(query, args, key)\n        this.dedupes.set(key, query)\n      } else {\n        this.onDedupe(key)\n      }\n\n      return query.promise\n    } catch (err) {\n      this.onError(err)\n    }\n  }\n\n  /**\n   * wrap the original func to sync storage\n   */\n  async wrapFunction (args, key) {\n    const storageKey = this.getStorageKey(key)\n    if (this.ttl > 0 || typeof this.ttl === 'function') {\n      const data = await this.get(storageKey)\n\n      if (data !== undefined) {\n        this.onHit(key)\n        const stale = typeof this.stale === 'function' ? this.stale(data) : this.stale\n        if (stale > 0) {\n          const remainingTTL = await this.storage.getTTL(storageKey)\n          if (remainingTTL <= stale) {\n            this._wrapFunction(storageKey, args, key).catch(noop)\n          }\n        }\n        return data\n      } else {\n        this.onMiss(key)\n      }\n    }\n\n    return this._wrapFunction(storageKey, args, key)\n  }\n\n  async _wrapFunction (storageKey, args, key) {\n    const result = await this.func(args, key)\n    const stale = typeof this.stale === 'function' ? this.stale(result) : this.stale\n    let ttl = typeof this.ttl === 'function' ? this.ttl(result) : this.ttl\n    if (ttl === undefined || ttl === null || (typeof ttl !== 'number' || !Number.isInteger(ttl))) {\n      this.onError(new Error('ttl must be an integer'))\n      return result\n    }\n    ttl += stale\n    if (ttl < 1) {\n      return result\n    }\n\n    if (!this.references) {\n      await this.set(storageKey, result, ttl)\n      return result\n    }\n\n    try {\n      let references = this.references(args, key, result)\n      let value = result\n      if (references && typeof references.then === 'function') { references = await references }\n      if (this.transformer) {\n        value = this.transformer.serialize(result)\n      }\n      // TODO validate references?\n      await this.storage.set(storageKey, value, ttl, references)\n    } catch (err) {\n      this.onError(err)\n    }\n\n    return result\n  }\n\n  buildPromise (query, args, key) {\n    query.promise = this.wrapFunction(args, key)\n\n    // we fork the promise chain on purpose\n    query.promise\n      .then(result => {\n        // clear the dedupe once done\n        this.dedupes.delete(key)\n        return result\n      })\n      .catch(err => {\n        this.onError(err)\n        this.dedupes.delete(key)\n        // TODO option to remove key from storage on error?\n        // we may want to relay on cache if the original function got error\n        // then we probably need more option for that\n        const r = this.storage.remove(this.getStorageKey(key))\n        if (r && typeof r.catch === 'function') { r.catch(noop) }\n      })\n  }\n\n  async clear (value) {\n    // TODO validate value?\n    if (value) {\n      const key = this.getKey(value)\n      this.dedupes.delete(key)\n      await this.storage.remove(this.getStorageKey(key))\n      return\n    }\n    await this.storage.clear(this.getStorageName())\n    this.dedupes.clear()\n  }\n\n  async get (key) {\n    const data = await this.storage.get(key)\n    if (this.transformer && !!data) {\n      return await this.transformer.deserialize(data)\n    }\n    return data\n  }\n\n  async set (key, value, ttl, references) {\n    if (this.transformer) {\n      value = this.transformer.serialize(value)\n    }\n    return this.storage.set(key, value, ttl, references)\n  }\n\n  async invalidate (references) {\n    return this.storage.invalidate(references)\n  }\n}\n\nclass Query {\n  constructor () {\n    this.promise = null\n  }\n}\n\nfunction noop () { }\n\nmodule.exports.Cache = Cache\n","const { Cache } = require('./src/cache')\nconst createStorage = require('./src/storage')\n\n/**\n   * @param {!Object} options\n   * @param {!Object} [options.storage] - the storage to use; default is `{ type: 'memory' }`\n   * @param {?number} [options.ttl=0] - in seconds; default is 0 seconds, so it only does dedupe without cache\n   * @param {?function} options.onDedupe\n   * @param {?function} options.onHit\n   * @param {?function} options.onMiss\n   */\nfunction createCache (options) {\n  if (!options) {\n    options = { storage: { type: 'memory' } }\n  } else if (!options.storage) {\n    options.storage = { type: 'memory' }\n  }\n  const storage = createStorage(options.storage.type, options.storage.options)\n  return new Cache({\n    ...options,\n    storage\n  })\n}\n\nmodule.exports = {\n  Cache,\n  createCache,\n  createStorage\n}\n","let tasks = 0\nlet resolves = []\n\nexport function startTask() {\n  tasks += 1\n  return () => {\n    tasks -= 1\n    if (tasks === 0) {\n      let prevResolves = resolves\n      resolves = []\n      for (let i of prevResolves) i()\n    }\n  }\n}\n\nexport function task(cb) {\n  let endTask = startTask()\n  let promise = cb().finally(endTask)\n  promise.t = true\n  return promise\n}\n\nexport function allTasks() {\n  if (tasks === 0) {\n    return Promise.resolve()\n  } else {\n    return new Promise(resolve => {\n      resolves.push(resolve)\n    })\n  }\n}\n\nexport function cleanTasks() {\n  tasks = 0\n}\n","import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let $store of stores) {\n    if ($store) {\n      if ($store.mocked) delete $store.mocked\n      if ($store[clean]) $store[clean]()\n    }\n  }\n}\n","import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\nexport let atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n","import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = (oldValue, changed) => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed, oldValue })\n      if (!isAborted) return originNotify(oldValue, changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n","import { atom } from '../atom/index.js'\n\nexport let map = (initial = {}) => {\n  let $map = atom(initial)\n\n  $map.setKey = function (key, value) {\n    let oldMap = $map.value\n    if (typeof value === 'undefined' && key in $map.value) {\n      $map.value = { ...$map.value }\n      delete $map.value[key]\n      $map.notify(oldMap, key)\n    } else if ($map.value[key] !== value) {\n      $map.value = {\n        ...$map.value,\n        [key]: value\n      }\n      $map.notify(oldMap, key)\n    }\n  }\n\n  return $map\n}\n","/** @internal */\nexport const runtime = typeof document === 'undefined' ? 'server' : 'browser'\n","import {runtime} from '../env'\nimport type {EnableLiveMode, EnableLiveModeOptions} from '../types'\nimport type {LazyEnableLiveModeOptions} from './enableLiveMode'\n\nexport const defineEnableLiveMode: (\n  config: Omit<LazyEnableLiveModeOptions, Exclude<keyof EnableLiveModeOptions, 'client'>>,\n) => EnableLiveMode = (config) => {\n  const {ssr, setFetcher} = config\n\n  return (options) => {\n    if (runtime === 'server') {\n      throw new Error('Live mode is not supported in server environments')\n    }\n    if (ssr && !options.client) {\n      throw new Error('The `client` option in `enableLiveMode` is required')\n    }\n\n    const client = options.client || config.client || undefined\n    const controller = new AbortController()\n    let disableLiveMode: (() => void) | undefined\n    import('./enableLiveMode').then(({enableLiveMode}) => {\n      if (controller.signal.aborted) return\n      disableLiveMode = enableLiveMode({...options, client, setFetcher, ssr})\n    })\n    return () => {\n      controller.abort()\n      disableLiveMode?.()\n    }\n  }\n}\n","import type {ClientPerspective, ContentSourceMap, QueryParams, SanityClient} from '@sanity/client'\nimport type {SanityStegaClient} from '@sanity/client/stega'\nimport {createCache, type Cache} from 'async-cache-dedupe'\nimport {atom, map, onMount, startTask, type MapStore} from 'nanostores'\nimport {runtime} from './env'\nimport {defineEnableLiveMode} from './live-mode'\nimport type {EnableLiveMode, Fetcher, QueryStoreState} from './types'\n\nexport type {MapStore}\n\nexport type * from './types'\nexport type {WritableAtom} from 'nanostores'\n\n/** @public */\nexport interface CreateQueryStoreOptions {\n  /**\n   * The Sanity client to use for fetching data, or `false` if `ssr: true` and it's set with `setServerClient` later\n   * You may use any client that is an `instanceof SanityClient` or `instanceof SanityStegaClient`.\n   * @example `import {createClient} from '@sanity/client'`\n   * @example `import {createClient} from '@sanity/client/stega'`\n   * @example `import {createClient} from '@sanity/preview-kit/client'`\n   * @example `import {createClient} from 'next-sanity'`\n   */\n  client: SanityClient | SanityStegaClient | false\n  /**\n   * If you want all data fetching to be done server-side in production, set this to `true` and `client: false`.\n   * Then, in your server entry file, you can set the Sanity client with `setServerClient`.\n   */\n  ssr?: boolean\n  /** @internal */\n  tag?: string\n}\n\n/** @public */\nexport interface QueryStore {\n  createFetcherStore: <QueryResponseResult = unknown, QueryResponseError = unknown>(\n    query: string,\n    params?: QueryParams,\n    /**\n     * Initial `data` and `sourceMap`, used with SSR hydration and is required if `ssr: true`\n     * and an optional speed optimization if `ssr: false`\n     */\n    initial?: {\n      data: QueryResponseResult\n      sourceMap?: ContentSourceMap\n      perspective?: ClientPerspective\n    },\n  ) => MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>>\n  /**\n   * When `ssr: true` you call this in your server entry point that imports the result of `createQueryStore` instance.\n   * It's required to call it before any data fetching is done.\n   */\n  setServerClient: (client: SanityClient | SanityStegaClient) => void\n  enableLiveMode: EnableLiveMode\n  /** @internal */\n  unstable__cache: {\n    instance: Cache & {\n      fetch: <QueryResponseResult>(key: string) => Promise<{\n        result: QueryResponseResult\n        resultSourceMap: ContentSourceMap | undefined\n      }>\n    }\n  }\n  /** @internal */\n  unstable__serverClient: {\n    /**\n     * Only set if `ssr: true` and `setServerClient` has been called.\n     */\n    instance: SanityClient | undefined\n    /**\n     * Will be `true` if the client given to `setServerClient` has a token configured.\n     */\n    canPreviewDrafts?: boolean\n  }\n}\n\nfunction cloneClientWithConfig(newClient: SanityClient): SanityClient {\n  return newClient.withConfig({\n    allowReconfigure: false,\n  })\n}\n\n/** @public */\nexport const createQueryStore = (options: CreateQueryStoreOptions): QueryStore => {\n  const {ssr = false, tag = 'core-loader'} = options\n  if (ssr && options.client) {\n    throw new TypeError(\n      '`client` option is not allowed when `ssr: true`, use `setServerClient` from your server entry point instead',\n    )\n  }\n  if (!ssr && options.client === false) {\n    throw new TypeError(`You must set \\`ssr: true\\` when \\`client: false\\` is used`)\n  }\n  if (!ssr && !options.client) {\n    throw new TypeError(`\\`client\\` is required`)\n  }\n  let client = ssr ? undefined : cloneClientWithConfig(options.client as SanityClient)\n\n  function createDefaultCache(client: SanityClient | undefined) {\n    return createCache().define('fetch', async (key: string) => {\n      if (!client) {\n        throw new Error(\n          `You have to set the Sanity client with \\`setServerClient\\` before any data fetching is done`,\n        )\n      }\n      const {query, params = {}, perspective, useCdn, stega} = JSON.parse(key)\n      const {result, resultSourceMap} = await client.fetch(query, params, {\n        tag,\n        filterResponse: false,\n        perspective,\n        useCdn,\n        stega,\n      })\n      return {result, resultSourceMap}\n    })\n  }\n\n  function createDefaultFetcher(): Fetcher {\n    const initialPerspective = client?.config().perspective || 'published'\n\n    unstable__cache.instance = createDefaultCache(client)\n\n    return {\n      hydrate: (_query, _params, initial) => ({\n        loading: initial?.data === undefined || initial?.sourceMap === undefined,\n        error: undefined,\n        data: initial?.data,\n        sourceMap: initial?.sourceMap,\n        perspective: initialPerspective,\n      }),\n      fetch: (query, params, $fetch, controller) => {\n        if (controller.signal.aborted) return\n\n        const finishTask = startTask()\n\n        $fetch.setKey('loading', true)\n        $fetch.setKey('error', undefined)\n        unstable__cache\n          .instance!.fetch(JSON.stringify({query, params}))\n          .then((response) => {\n            if (controller.signal.aborted) return\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            $fetch.setKey('data', response.result as any)\n            $fetch.setKey('sourceMap', response.resultSourceMap)\n            $fetch.setKey('perspective', initialPerspective)\n          })\n          .catch((reason) => {\n            $fetch.setKey('error', reason)\n          })\n          .finally(() => {\n            $fetch.setKey('loading', false)\n            finishTask()\n          })\n      },\n    } satisfies Fetcher\n  }\n\n  const unstable__cache: QueryStore['unstable__cache'] = {\n    instance: createDefaultCache(client),\n  }\n\n  const $fetcher = atom<Fetcher | undefined>(client ? createDefaultFetcher() : undefined)\n\n  const enableLiveMode = defineEnableLiveMode({\n    client: client || undefined,\n    ssr,\n    setFetcher: (fetcher) => {\n      const originalFetcher = $fetcher.get()\n      $fetcher.set(fetcher)\n      return () => $fetcher.set(originalFetcher)\n    },\n  })\n\n  const createFetcherStore: QueryStore['createFetcherStore'] = <\n    QueryResponseResult,\n    QueryResponseError,\n  >(\n    query: string,\n    params: QueryParams = {},\n    initial?: Pick<\n      QueryStoreState<QueryResponseResult, QueryResponseError>,\n      'data' | 'sourceMap' | 'perspective'\n    >,\n  ): MapStore<QueryStoreState<QueryResponseResult, QueryResponseError>> => {\n    const fetcher = $fetcher.get()\n    const $fetch = map<QueryStoreState<QueryResponseResult, QueryResponseError>>(\n      fetcher\n        ? fetcher.hydrate(query, params, initial)\n        : {\n            loading: false,\n            error:\n              typeof initial?.data === 'undefined'\n                ? (new Error(\n                    `The \\`initial\\` option is required when \\`ssr: true\\``,\n                  ) as QueryResponseError)\n                : undefined,\n            data: initial?.data,\n            sourceMap: initial?.sourceMap,\n            perspective: initial?.perspective,\n          },\n    )\n\n    onMount($fetch, () => {\n      let controller = new AbortController()\n      const unsubscribe = $fetcher.subscribe((fetcher) => {\n        if (!fetcher || controller.signal.aborted) return\n        controller.abort()\n        controller = new AbortController()\n        fetcher.fetch(query, params, $fetch, controller)\n      })\n\n      return () => {\n        controller.abort()\n        unsubscribe()\n      }\n    })\n\n    return $fetch\n  }\n  const unstable__serverClient: QueryStore['unstable__serverClient'] = {\n    instance: undefined,\n    canPreviewDrafts: false,\n  }\n  const setServerClient: QueryStore['setServerClient'] = (newClient) => {\n    if (runtime !== 'server') {\n      throw new Error(\n        '`setServerClient` can only be called in server environments, detected: ' +\n          JSON.stringify(runtime),\n      )\n    }\n    if (!ssr) {\n      throw new Error('`setServerClient` can only be called when `ssr: true`')\n    }\n    unstable__serverClient.instance = client = cloneClientWithConfig(newClient as SanityClient)\n    unstable__serverClient.canPreviewDrafts = !!client.config().token\n    $fetcher.set(createDefaultFetcher())\n  }\n\n  return {\n    createFetcherStore,\n    enableLiveMode,\n    setServerClient,\n    unstable__cache,\n    unstable__serverClient,\n  }\n}\n\nexport {runtime} from './env'\n"],"names":["exports","module","value","tmp","key","res","join","stringify","require$$0","require$$1","require$$2","keys","iterator","support","iterables","require$$3","cache","storage","client","createCache","fetcher"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}